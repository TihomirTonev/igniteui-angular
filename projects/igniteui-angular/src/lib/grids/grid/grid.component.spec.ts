import {
    AfterViewInit, ChangeDetectorRef, Component, Injectable,
    OnInit, ViewChild, TemplateRef
} from '@angular/core';
import { async, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { BehaviorSubject, Observable } from 'rxjs';
import { By } from '@angular/platform-browser';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { IgxGridComponent } from './grid.component';
import { IgxRowDirective } from '../row.directive';
import { IgxColumnComponent } from '../columns/column.component';
import { IForOfState } from '../../directives/for-of/for_of.directive';
import { IgxGridModule } from './index';
import { DisplayDensity } from '../../core/displayDensity';
import { DataType } from '../../data-operations/data-util';
import { GridTemplateStrings } from '../../test-utils/template-strings.spec';
import { SampleTestData } from '../../test-utils/sample-test-data.spec';
import { BasicGridComponent } from '../../test-utils/grid-base-components.spec';
import { wait } from '../../test-utils/ui-interactions.spec';
import { IgxStringFilteringOperand, IgxNumberFilteringOperand } from '../../data-operations/filtering-condition';
import { SortingDirection, ISortingExpression } from '../../data-operations/sorting-expression.interface';
import { configureTestSuite } from '../../test-utils/configure-suite';
import { IgxTabsModule, IgxTabsComponent } from '../../tabs';
import { resizeObserverIgnoreError } from '../../test-utils/helper-utils.spec';
import { GridSelectionMode } from '../common/enums';


describe('IgxGrid Component Tests #grid', () => {
    const MIN_COL_WIDTH = '136px';
    const COLUMN_HEADER_CLASS = '.igx-grid__th';

    const TBODY_CLASS = '.igx-grid__tbody-content';
    const THEAD_CLASS = '.igx-grid__thead';

    describe('IgxGrid - input properties', () => {
        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridTestComponent,
                    IgxGridMarkupDeclarationComponent,
                    IgxGridRemoteVirtualizationComponent,
                    IgxGridRemoteOnDemandComponent,
                    IgxGridEmptyMessage100PercentComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule]
            }).compileComponents();
        }));

        it('should initialize a grid with columns from markup', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridMarkupDeclarationComponent);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.instance;
            const domGrid = fix.debugElement.query(By.css('igx-grid')).nativeElement;

            expect(grid).toBeDefined('Grid initializing through markup failed');
            expect(grid.columnList.length).toEqual(2, 'Invalid number of columns initialized');
            expect(grid.rowList.length).toEqual(3, 'Invalid number of rows initialized');

            expect(grid.id).toContain('igx-grid-');
            expect(domGrid.id).toContain('igx-grid-');

            grid.id = 'customGridId';
            fix.detectChanges();

            expect(grid.id).toBe('customGridId');
            expect(domGrid.id).toBe('customGridId');
            expect(fix.componentInstance.columnEventCount).toEqual(2);
        }));

        it('should initialize a grid with autogenerated columns', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.componentInstance.data = [
                { Number: 1, String: '1', Boolean: true, Date: new Date(Date.now()) }
            ];
            fix.componentInstance.columns = [];
            fix.componentInstance.autoGenerate = true;
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;

            expect(grid).toBeDefined('Grid initializing through autoGenerate failed');
            expect(grid.columnList.length).toEqual(4, 'Invalid number of columns initialized');
            expect(grid.rowList.length).toEqual(1, 'Invalid number of rows initialized');
            expect(grid.columnList.first.dataType).toEqual(DataType.Number, 'Invalid dataType set on column');
            expect(grid.columnList.find((col) => col.index === 1).dataType)
                .toEqual(DataType.String, 'Invalid dataType set on column');
            expect(grid.columnList.find((col) => col.index === 2).dataType)
                .toEqual(DataType.Boolean, 'Invalid dataType set on column');
            expect(grid.columnList.last.dataType).toEqual(DataType.Date, 'Invalid dataType set on column');
            expect(fix.componentInstance.columnEventCount).toEqual(4);
        }));

        it('should initialize a grid and change column properties during initialization', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.componentInstance.columns = [];
            fix.componentInstance.autoGenerate = true;
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;

            grid.columnList.forEach((column) => {
                expect(column.filterable).toEqual(true);
                expect(column.sortable).toEqual(true);
            });
        }));

        it('should initialize grid with remote virtualization', async () => {
            const fix = TestBed.createComponent(IgxGridRemoteVirtualizationComponent);
            fix.detectChanges();
            await wait(16);
            let rows = fix.componentInstance.instance.rowList.toArray();
            expect(rows.length).toEqual(10);

            const verticalScroll = fix.componentInstance.instance.verticalScrollContainer;
            const elem = verticalScroll['scrollComponent'].elementRef.nativeElement;

            // scroll down
            expect(() => {
                elem.scrollTop = 1000;
                fix.detectChanges();
                fix.componentRef.hostView.detectChanges();
            }).not.toThrow();

            fix.detectChanges();
            fix.componentInstance.cdr.detectChanges();
            await wait(16);
            rows = fix.componentInstance.instance.rowList.toArray();
            const data = fix.componentInstance.data.source.getValue();
            for (let i = fix.componentInstance.instance.virtualizationState.startIndex; i < rows.length; i++) {
                expect(rows[i].rowData['Col1'])
                    .toBe(data[i]['Col1']);
            }
        });

        it('should remove all rows if data becomes null/undefined.', async () => {
            const fix = TestBed.createComponent(IgxGridRemoteVirtualizationComponent);
            fix.detectChanges();
            const grid = fix.componentInstance.instance;
            expect(grid.rowList.length).toEqual(10);

            fix.componentInstance.nullData();
            fix.detectChanges();

            const noRecordsSpan = fix.debugElement.query(By.css('.igx-grid__tbody-message'));
            expect(grid.rowList.length).toEqual(0);
            expect(noRecordsSpan).toBeTruthy();
            expect(noRecordsSpan.nativeElement.innerText).toBe('Grid has no data.');
        });

        it('height/width should be calculated depending on number of records', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.detectChanges();
            const grid = fix.componentInstance.grid;
            fix.componentInstance.grid.height = null;
            fix.detectChanges();

            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            const gridHeader = fix.debugElement.query(By.css(THEAD_CLASS));
            const gridFooter = fix.debugElement.query(By.css('.igx-grid__tfoot'));
            const gridScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            let gridBodyHeight;
            let verticalScrollHeight;

            expect(grid.rowList.length).toEqual(1);
            expect(window.getComputedStyle(gridBody.nativeElement).height).toMatch('51px');

            for (let i = 2; i <= 30; i++) {
                grid.addRow({ index: i, value: i });
            }

            fix.detectChanges();

            expect(grid.rowList.length).toEqual(30);
            expect(window.getComputedStyle(gridBody.nativeElement).height).toMatch('1530px');
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(false);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(false);

            grid.height = '200px';
            fix.detectChanges();

            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(true);
            // no horizontal scr, since columns have no width hence they should
            // distrubute the available width between them
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(false);
            verticalScrollHeight = fix.componentInstance.getVerticalScrollHeight();

            grid.width = '200px';
            fix.detectChanges();

            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.isHorizontalScrollbarVisible()).toBe(true);
            expect(fix.componentInstance.getVerticalScrollHeight()).toBeLessThan(verticalScrollHeight);
            gridBodyHeight = parseInt(window.getComputedStyle(grid.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridHeader.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridFooter.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridScroll.nativeElement).height, 10);

            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('200px');
            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('200px');
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toEqual(gridBodyHeight);

            grid.height = '50%';
            fix.detectChanges();
            grid.width = '50%';
            fix.detectChanges();

            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('300px');
            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('400px');

            gridBodyHeight = parseInt(window.getComputedStyle(grid.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridHeader.nativeElement).height, 10)
                - parseInt(window.getComputedStyle(gridFooter.nativeElement).height, 10);

            // The scrollbar is no longer visible
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toEqual(gridBodyHeight);
        }));

        it('should not have column misalignment when no vertical scrollbar is shown', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;
            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            const gridHeader = fix.debugElement.query(By.css(THEAD_CLASS));

            expect(window.getComputedStyle(gridBody.children[0].nativeElement).width).toEqual(
                window.getComputedStyle(gridHeader.children[0].nativeElement).width
            );
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it('should change displayDensity runtime correctly', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.columns[1].hasSummary = true;
            fixture.detectChanges();

            const grid = fixture.componentInstance.grid;
            const headerHight = fixture.debugElement.query(By.css(THEAD_CLASS)).query(By.css('.igx-grid__tr')).nativeElement;
            const rowHeight = fixture.debugElement.query(By.css(TBODY_CLASS)).query(By.css('.igx-grid__tr')).nativeElement;
            const summaryItemHeigh = fixture.debugElement.query(By.css('.igx-grid__tfoot'))
                .query(By.css('.igx-grid-summary__item')).nativeElement;

            expect(grid.defaultRowHeight).toBe(50);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(51);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultSummaryHeight - 1);
            grid.displayDensity = 'cosy';
            tick(16);
            fixture.detectChanges();

            expect(grid.nativeElement.classList.contains('igx-grid--cosy')).toBe(true);
            expect(grid.defaultRowHeight).toBe(40);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(41);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultSummaryHeight - 1);
            grid.displayDensity = 'compact';
            tick(16);
            fixture.detectChanges();

            expect(grid.nativeElement.classList.contains('igx-grid--compact')).toBe(true);
            expect(grid.defaultRowHeight).toBe(32);
            expect(headerHight.offsetHeight).toBe(grid.defaultRowHeight);
            expect(rowHeight.offsetHeight).toBe(33);
            expect(summaryItemHeigh.offsetHeight).toBe(grid.defaultSummaryHeight - 1);
        }));

        it('should render empty message', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.grid;
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            const domGrid = fixture.debugElement.query(By.css('igx-grid')).nativeElement;

            // make sure default width/height are applied when there is no data
            expect(domGrid.style.height).toBe('100%');
            expect(domGrid.style.width).toBe('100%');

            // Check for loaded rows in grid's container
            fixture.componentInstance.generateData(30);
            fixture.detectChanges();
            tick(1000);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            // Check for empty filter grid message and body less than 100px
            const columns = fixture.componentInstance.grid.columns;
            grid.filter(columns[0].field, 546000, IgxNumberFilteringOperand.instance().condition('equals'));
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.textContent).toEqual(grid.emptyFilteredGridMessage);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            // Clear filter and check if grid's body height is restored based on all loaded rows
            grid.clearFilter(columns[0].field);
            fixture.detectChanges();
            tick(100);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);

            expect(gridBody.nativeElement.innerText).toMatch(grid.emptyGridMessage);
        }));

        it('should render loading indicator when loading is enabled', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.componentInstance.grid.isLoading = true;
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.grid;
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            let loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            const domGrid = fixture.debugElement.query(By.css('igx-grid')).nativeElement;

            // make sure default width/height are applied when there is no data
            expect(domGrid.style.height).toBe('100%');
            expect(domGrid.style.width).toBe('100%');

            expect(loadingIndicator).not.toBeNull();
            expect(gridBody.nativeElement.textContent).not.toEqual(grid.emptyFilteredGridMessage);

            // Check for loaded rows in grid's container
            fixture.componentInstance.generateData(30);
            fixture.detectChanges();
            tick(1000);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).toBeNull();

            // Check for empty filter grid message and body less than 100px
            const columns = fixture.componentInstance.grid.columns;
            grid.filter(columns[0].field, 546000, IgxNumberFilteringOperand.instance().condition('equals'));
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.textContent).toEqual(grid.emptyFilteredGridMessage);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            // Clear filter and check if grid's body height is restored based on all loaded rows
            grid.clearFilter(columns[0].field);
            fixture.detectChanges();
            tick(100);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).not.toBeNull();
        }));

        it('should render loading indicator when loading is enabled when there is height', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.componentInstance.grid.isLoading = true;
            fixture.componentInstance.grid.height = '400px';
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.grid;
            const gridElement = fixture.debugElement.query(By.css('.igx-grid'));
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            let loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));

            expect(loadingIndicator).not.toBeNull();
            expect(gridBody.nativeElement.textContent).not.toEqual(grid.emptyFilteredGridMessage);

            // Check for loaded rows in grid's container
            fixture.componentInstance.generateData(30);
            fixture.detectChanges();
            tick(1000);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(300);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).toBeNull();

            // the overlay should be shown
            loadingIndicator = gridElement.query(By.css('.igx-grid__loading-outlet'));
            expect(loadingIndicator.nativeElement.children.length).not.toBe(0);

            // Check for empty filter grid message and body less than 100px
            const columns = fixture.componentInstance.grid.columns;
            grid.filter(columns[0].field, 546000, IgxNumberFilteringOperand.instance().condition('equals'));
            fixture.detectChanges();
            tick(100);
            expect(gridBody.nativeElement.textContent).toEqual(grid.emptyFilteredGridMessage);

            // Clear filter and check if grid's body height is restored based on all loaded rows
            grid.clearFilter(columns[0].field);
            fixture.detectChanges();
            tick(100);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(300);

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).not.toBeNull();

            // the overlay should be hidden
            loadingIndicator = gridElement.query(By.css('.igx-grid__loading-outlet'));
            expect(loadingIndicator.nativeElement.children.length).toBe(0);
        }));

        it('should render loading indicator when loading is enabled and autoGenerate is enabled', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.componentInstance.grid.isLoading = true;
            fixture.componentInstance.columns = [];
            fixture.componentInstance.autoGenerate = true;
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.grid;
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            const gridHead = fixture.debugElement.query(By.css(THEAD_CLASS));
            let loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            let colHeaders = gridHead.queryAll(By.css('igx-grid-header'));

            expect(loadingIndicator).not.toBeNull();
            expect(colHeaders.length).toBe(0);
            expect(gridBody.nativeElement.textContent).not.toEqual(grid.emptyFilteredGridMessage);

            // Check for loaded rows in grid's container
            fixture.componentInstance.grid.shouldGenerate = true;
            fixture.componentInstance.data = [
                { Number: 1, String: '1', Boolean: true, Date: new Date(Date.now()) }
            ];
            fixture.detectChanges();
            tick(1000);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            colHeaders = gridHead.queryAll(By.css('igx-grid-header'));
            expect(colHeaders.length).toBeGreaterThan(0);
            expect(loadingIndicator).toBeNull();

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).not.toBeNull();
        }));

        it('should render loading indicator when loading is enabled and autoGenerate is enabled and async data', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridRemoteOnDemandComponent);
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.instance;
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            const gridHead = fixture.debugElement.query(By.css(THEAD_CLASS));
            let loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));

            expect(loadingIndicator).not.toBeNull();
            expect(gridBody.nativeElement.textContent).not.toEqual(grid.emptyFilteredGridMessage);

            fixture.componentInstance.bind();

            const colHeaders = gridHead.queryAll(By.css('igx-grid-header'));
            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(colHeaders.length).toBeGreaterThan(0);
            expect(loadingIndicator).toBeNull();
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(500);
        }));

        it('should allow applying custom loading indicator', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridRemoteOnDemandComponent);
            fixture.componentInstance.instance.loadingGridTemplate = fixture.componentInstance.customTemaplate;
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.instance;
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            const gridHead = fixture.debugElement.query(By.css(THEAD_CLASS));

            expect(gridBody.nativeElement.textContent).toEqual('Loading...');
            expect(gridBody.nativeElement.textContent).not.toEqual(grid.emptyFilteredGridMessage);

            fixture.componentInstance.bind();

            const colHeaders = gridHead.queryAll(By.css('igx-grid-header'));
            expect(colHeaders.length).toBeGreaterThan(0);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(500);
        }));

        it('should remove loading overlay when isLoading is set to false', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridTestComponent);
            fixture.componentInstance.data = [];
            fixture.componentInstance.grid.isLoading = true;
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.grid;
            const gridElement = fixture.debugElement.query(By.css('.igx-grid'));
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            let loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));

            expect(loadingIndicator).not.toBeNull();
            expect(gridBody.nativeElement.textContent).not.toEqual(grid.emptyFilteredGridMessage);

            // Check for loaded rows in grid's container
            fixture.componentInstance.generateData(30);
            fixture.detectChanges();
            tick(1000);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(548);

            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).toBeNull();

            // the overlay should be shown
            loadingIndicator = gridElement.query(By.css('.igx-grid__loading-outlet'));
            expect(loadingIndicator.nativeElement.children.length).not.toBe(0);

            grid.isLoading = false;
            tick(16);
            expect(loadingIndicator.nativeElement.children.length).toBe(0);

            // Clearing grid's data and check for empty grid message
            fixture.componentInstance.clearData();
            fixture.detectChanges();
            tick(100);

            // isLoading is still false so the empty data message should show, not the loading indicator
            loadingIndicator = gridBody.query(By.css('.igx-grid__loading'));
            expect(loadingIndicator).toBeNull();

            expect(gridBody.nativeElement.textContent).toEqual(grid.emptyGridMessage);
        }));

        it('should render empty message when grid height is 100%', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridEmptyMessage100PercentComponent);
            fixture.detectChanges();
            tick(16);

            const grid = fixture.componentInstance.grid;
            const gridBody = fixture.debugElement.query(By.css(TBODY_CLASS));
            const domGrid = fixture.debugElement.query(By.css('igx-grid')).nativeElement;

            // make sure default width/height are applied when there is no data
            expect(domGrid.style.height).toBe('100%');
            expect(domGrid.style.width).toBe('100%');

            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBeGreaterThan(0);
            expect(gridBody.nativeElement.innerText).toMatch(grid.emptyGridMessage);
        }));
    });

    describe('IgxGrid - virtualization tests', () => {
        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridTestComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule]
            }).compileComponents();
        }));

        it('should change chunk size for every record after enlarging the grid and the horizontal dirs are scrambled', async () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            for (let i = 2; i < 100; i++) {
                fix.componentInstance.data.push({ index: i, value: i, desc: i, detail: i });
            }
            fix.componentInstance.columns[0].width = '400px';
            fix.componentInstance.columns[1].width = '400px';
            fix.componentInstance.columns.push(
                { field: 'desc', header: 'desc', dataType: 'number', width: '400px', hasSummary: false },
                { field: 'detail', header: 'detail', dataType: 'number', width: '400px', hasSummary: false }
            );
            fix.detectChanges();
            fix.componentInstance.grid.verticalScrollContainer.getScroll().scrollTop = 100;
            await wait(100);
            fix.detectChanges();
            fix.componentInstance.grid.verticalScrollContainer.getScroll().scrollTop = 250;
            await wait(100);
            fix.detectChanges();
            fix.componentInstance.grid.width = '1300px';
            await wait(100);
            fix.detectChanges();
            const rows = fix.componentInstance.grid.rowList.toArray();
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i] as IgxRowDirective<any>;
                expect(row.cells.length).toEqual(4);
            }
        });

        it('should not keep a cached-out template as master after column resizing', async () => {
            const fix = TestBed.createComponent(IgxGridTestComponent);
            for (let i = 2; i < 100; i++) {
                fix.componentInstance.data.push({ index: i, value: i, desc: i, detail: i });
            }
            fix.componentInstance.columns[0].width = '400px';
            fix.componentInstance.columns[1].width = '400px';
            fix.componentInstance.columns.push(
                { field: 'desc', header: 'desc', dataType: 'number', width: '400px', hasSummary: false },
                { field: 'detail', header: 'detail', dataType: 'number', width: '400px', hasSummary: false }
            );
            fix.detectChanges();
            fix.componentInstance.grid.groupBy({ fieldName: 'value', dir: SortingDirection.Asc });
            fix.detectChanges();
            fix.componentInstance.grid.getColumnByName('index').width = '100px';
            fix.detectChanges();
            await wait(16);
            const rows = fix.componentInstance.grid.dataRowList.toArray();
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i] as IgxRowDirective<any>;
                expect(row.cells.length).toEqual(4);
            }
        });
    });

    describe('IgxGrid - default rendering for rows and columns', () => {
        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent,
                    IgxGridColumnPercentageWidthComponent,
                    IgxGridWrappedInContComponent,
                    IgxGridFormattingComponent,
                    IgxGridFixedContainerHeightComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule]
            }).compileComponents();
        }));

        it('should init columns with width >= 136px when 5 rows and 5 columns are rendered', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(5, 5);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[2].width).not.toBeLessThan(136);
            expect(grid.width).toMatch('100%');
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it('should init columns with width >= 136px when 30 rows and 10 columns are rendered', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(30, 10);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[6].width).not.toBeLessThan(136);
            expect(grid.width).toMatch('100%');
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should init columns with width >= 136px and a horizontal scrollbar
            when 1000 rows and 30 columns are rendered`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(1000, 30);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[14].width).not.toBeLessThan(136);
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
        }));

        it(`should init columns with width >= 136px and a horizontal scrollbar
            when 200 rows and 150 columns are rendered`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(200, 150);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;

            expect(grid.columns[0].width).not.toBeLessThan(136);
            expect(grid.columns[4].width).not.toBeLessThan(136);
            expect(grid.columns[100].width).not.toBeLessThan(136);
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it('should account for columns with set width when determining default column width when grid has 100% width', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(5, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('100px');
            expect(grid.columns[4].width).toEqual('100px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it('should account for columns with set width when determining default column width when grid has px width', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '600px';
            fix.componentInstance.initColumnsRows(5, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('600px');
            expect(grid.columns[0].width).toEqual('100px');
            expect(grid.columns[4].width).toEqual('100px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are enough rows to cover the grid's height`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(30, 5);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('100px');
            expect(grid.columns[4].width).toEqual('100px');

            const actualGridWidth = grid.unpinnedWidth;

            const expectedDefWidth = Math.max(Math.floor((actualGridWidth -
                parseInt(grid.columns[0].width, 10) -
                parseInt(grid.columns[4].width, 10)) / 3),
                parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[3].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 4) {
                    expect(width).toBeGreaterThanOrEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are enough rows to cover the grid's height and enough columns to cover the grid's width`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(1000, 30);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[3].width).toEqual('200px');
            expect(grid.columns[5].width).toEqual('200px');
            expect(grid.columns[10].width).toEqual('200px');
            expect(grid.columns[25].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;

            const expectedDefWidth = Math.max(Math.floor((actualGridWidth - 5 * 200) / 25), parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[1].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[2].width, 10)).toEqual(expectedDefWidth);
            expect(parseInt(grid.columns[4].width, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 25) {
                    expect(width).toEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should account for columns with set width when determining default column width when grid has px width
            and there are enough rows to cover the grid's height and enough columns to cover the grid's width`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '800px';
            fix.componentInstance.initColumnsRows(1000, 30);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('800px');
            expect(grid.columns[0].width).toEqual('200px');
            expect(grid.columns[3].width).toEqual('200px');
            expect(grid.columns[5].width).toEqual('200px');
            expect(grid.columns[10].width).toEqual('200px');
            expect(grid.columns[25].width).toEqual('200px');

            const actualGridWidth = grid.nativeElement.clientWidth;
            const expectedDefWidth = Math.max(Math.floor((actualGridWidth - 5 * 200) / 25), parseInt(MIN_COL_WIDTH, 10));
            expect(parseInt(grid.columnWidth, 10)).toEqual(expectedDefWidth);

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 25) {
                    expect(width).toEqual(minWidth);
                }
            });
            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should account for columns with set width when determining default column width when grid has 100% width
            and there are 10000 rows and 150 columns`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(10000, 150);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('100%');
            expect(grid.columns[0].width).toEqual('500px');
            expect(grid.columns[3].width).toEqual('500px');
            expect(grid.columns[5].width).toEqual('500px');
            expect(grid.columns[10].width).toEqual('500px');
            expect(grid.columns[50].width).toEqual('500px');

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 50) {
                    expect(width).toEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should account for columns with set width when determining default column width when grid has px width
            and there are 10000 rows and 150 columns`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            grid.width = '800px';
            fix.componentInstance.initColumnsRows(10000, 150);
            fix.componentInstance.changeInitColumns = true;
            fix.detectChanges();
            tick(16);

            expect(grid.width).toEqual('800px');
            expect(grid.columns[0].width).toEqual('500px');
            expect(grid.columns[3].width).toEqual('500px');
            expect(grid.columns[5].width).toEqual('500px');
            expect(grid.columns[10].width).toEqual('500px');
            expect(grid.columns[50].width).toEqual('500px');

            grid.columns.forEach((column) => {
                const width = parseInt(column.width, 10);
                const minWidth = parseInt(grid.columnWidth, 10);
                if (column.index !== 0 && column.index !== 3 && column.index !== 5 &&
                    column.index !== 10 && column.index !== 50) {
                    expect(width).toEqual(minWidth);
                }
            });

            expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it('should render all records if height is explicitly set to null.', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.initColumnsRows(20, 5);
            grid.height = null;
            fix.detectChanges();
            tick(16);

            const recsCount = grid.data.length;

            // tbody should have height equal to all items * item height
            expect(grid.tbody.nativeElement.clientHeight).toEqual(recsCount * 51);
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it('should match width and height of parent container when width/height are set in %', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            const grid = fix.componentInstance.grid;
            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.componentInstance.outerWidth = 800;
            fix.componentInstance.outerHeight = 600;
            fix.componentInstance.grid.width = '50%';
            fix.componentInstance.grid.height = '50%';
            fix.detectChanges();
            tick(16);

            expect(window.getComputedStyle(grid.nativeElement).height).toMatch('300px');
            expect(window.getComputedStyle(grid.nativeElement).width).toMatch('400px');
            expect(grid.rowList.length).toBeGreaterThan(0);
        }));

        it(`should render 10 records if height is unset and parent container's height is unset`, () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();
            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.detectChanges();
            const defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(400);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toBeGreaterThanOrEqual(10);
        });

        it(`should render pixel height when one is set and parent container's height is unset`, () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();
            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.componentInstance.grid.height = '700px';
            fix.detectChanges();

            const defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).not.toBeNull();
            expect(parseInt(defaultHeight, 10)).toBeGreaterThan(400);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
            expect(fix.componentInstance.grid.rowList.length).toBeGreaterThanOrEqual(10);
        });

        it(`should render all records exactly if height is 100% and parent container's height is unset and
            there are fewer than 10 records in the data view`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.grid.height = '100%';
            fix.componentInstance.data = fix.componentInstance.semiData;
            fix.detectChanges();
            tick(16);
            const defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull();
            expect(fix.debugElement.query(By.css(TBODY_CLASS))
                .nativeElement.getBoundingClientRect().height).toBeGreaterThan(200);
            expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeFalsy();
            expect(fix.componentInstance.grid.rowList.length).toEqual(5);
        }));

        it(`should render 10 records if height is 100% and parent container's height is unset and
            display density is changed`, async () => {
                const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
                fix.detectChanges();

                fix.componentInstance.grid.height = '100%';
                fix.componentInstance.data = fix.componentInstance.fullData.slice(0, 11);
                fix.detectChanges();
                await wait(100);

                fix.componentInstance.density = DisplayDensity.compact;
                fix.detectChanges();
                await wait(100);

                const defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
                const defaultHeightNum = parseInt(defaultHeight, 10);
                expect(defaultHeight).not.toBeNull();
                expect(defaultHeightNum).toBe(330);
                expect(fix.componentInstance.isVerticalScrollbarVisible()).toBeTruthy();
                expect(fix.componentInstance.grid.rowList.length).toEqual(11);
            });

        it(`should render grid with correct height when parent container's height is set
            and the total row height is smaller than parent height #1861`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridFixedContainerHeightComponent);
            fix.componentInstance.grid.height = '100%';
            fix.componentInstance.paging = true;
            fix.componentInstance.data = fix.componentInstance.data.slice(0, 5);

            tick();
            fix.detectChanges();
            const domGrid = fix.debugElement.query(By.css('igx-grid')).nativeElement;
            expect(parseInt(window.getComputedStyle(domGrid).height, 10)).toBe(300);
        }));

        it(`should render grid with correct height when height is in percent and the
            sum height of all rows is lower than parent height #1858`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridFixedContainerHeightComponent);
            fix.componentInstance.grid.height = '100%';
            fix.componentInstance.data = fix.componentInstance.data.slice(0, 3);

            tick();
            fix.detectChanges();
            const domGrid = fix.debugElement.query(By.css('igx-grid')).nativeElement;
            expect(parseInt(window.getComputedStyle(domGrid).height, 10)).toBe(300);
        }));

        it('should keep auto-sizing if initial data is empty then set to a new array', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            tick();
            fix.detectChanges();
            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull(); // initially body height is null in auto-sizing scenarios with empty data
            expect(fix.componentInstance.grid.calcHeight).toBeNull();
            fix.componentInstance.data = fix.componentInstance.fullData;
            tick();
            fix.detectChanges();
            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            const defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);
        }));

        it('should keep auto-sizing if initial data is set to empty array that is then filled', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();

            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull(); // initially body height is null in auto-sizing scenarios with empty data
            expect(fix.componentInstance.grid.calcHeight).toBeNull();

            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.detectChanges();

            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            const defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);
        }));

        it(`should not render with calcHeight null at any point when loading data and
            auto-sizing is required and initial data is empty`, () => {
                const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
                fix.detectChanges();

                let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
                expect(defaultHeight).toBeNull(); // initially body height is null in auto-sizing scenarios with empty data
                expect(fix.componentInstance.grid.calcHeight).toBeNull();

                fix.componentInstance.data = Array.from({ length: 100000 }, (_, i) => ({ 'ID': i, 'CompanyName': 'CN' + i }));
                fix.detectChanges();

                defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
                const defaultHeightNum = parseInt(defaultHeight, 10);
                expect(defaultHeight).not.toBeNull();
                expect(defaultHeightNum).toBe(510);
                expect(fix.componentInstance.grid.calcHeight).toBe(510);
            });

        it('should keep auto-sizing if initial data is set to small array that is then filled', () => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.data = fix.componentInstance.semiData;
            fix.detectChanges();

            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull();
            expect(fix.componentInstance.grid.calcHeight).toBeNull();
            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.detectChanges();

            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            const defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);
        });

        it(`should render with calcHeight null if initial data is small but then
            auto-size when it is filled`, async () => {
                const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
                fix.componentInstance.data = fix.componentInstance.semiData;
                fix.detectChanges();
                let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
                expect(defaultHeight).toBeNull();
                expect(fix.componentInstance.grid.calcHeight).toBeNull();
                fix.componentInstance.data = Array.from({ length: 100000 }, (_, i) => ({ 'ID': i, 'CompanyName': 'CN' + i }));
                fix.detectChanges();
                await wait(500);
                defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
                const defaultHeightNum = parseInt(defaultHeight, 10);
                expect(defaultHeight).not.toBeNull();
                expect(defaultHeightNum).toBe(510);
                expect(fix.componentInstance.grid.calcHeight).toBe(510);
            });

        it('should keep default height when filtering', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            tick();
            fix.detectChanges();
            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull(); // initially body height is null in auto-sizing scenarios with empty data
            expect(fix.componentInstance.grid.calcHeight).toBeNull();
            fix.componentInstance.data = fix.componentInstance.fullData;
            tick();
            fix.detectChanges();
            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            let defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);
            fix.componentInstance.grid.filter('ID', 'ALFKI', IgxStringFilteringOperand.instance().condition('equals'));
            tick();
            fix.detectChanges();
            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);
        }));

        it('should not keep default height when lower the amount of bound data', async() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();

            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull(); // initially body height is null in auto-sizing scenarios with empty data
            expect(fix.componentInstance.grid.calcHeight).toBeNull();

            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.detectChanges();

            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            const defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);

            fix.componentInstance.grid.data = fix.componentInstance.semiData;
            fix.detectChanges();
            await wait(100);
            fix.detectChanges();

            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull();
            expect(fix.componentInstance.grid.calcHeight).toBeNull();
        });

        it('should not keep auto-sizing when changing height', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.detectChanges();

            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            expect(defaultHeight).toBeNull(); // initially body height is null in auto-sizing scenarios with empty data
            expect(fix.componentInstance.grid.calcHeight).toBeNull();

            fix.componentInstance.data = fix.componentInstance.fullData;
            fix.detectChanges();

            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            let defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBe(510);
            expect(fix.componentInstance.grid.calcHeight).toBe(510);

            fix.componentInstance.grid.height = '400px';
            fix.detectChanges();

            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBeLessThan(400);
            expect(defaultHeightNum).toBeGreaterThan(300);
            expect(fix.componentInstance.grid.calcHeight).toBeLessThan(400);
            expect(fix.componentInstance.grid.calcHeight).toBeGreaterThan(300);
        }));

        it('should not auto-size when changing height is determinable', fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridWrappedInContComponent);
            fix.componentInstance.outerHeight = 800;
            tick();
            fix.detectChanges();
            let defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            let defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBeLessThan(800);
            expect(defaultHeightNum).toBeGreaterThan(700);
            expect(fix.componentInstance.grid.calcHeight).toBeLessThan(800);
            expect(fix.componentInstance.grid.calcHeight).toBeGreaterThan(700);
            fix.componentInstance.data = fix.componentInstance.fullData;
            tick();
            fix.detectChanges();
            defaultHeight = fix.debugElement.query(By.css(TBODY_CLASS)).styles.height;
            defaultHeightNum = parseInt(defaultHeight, 10);
            expect(defaultHeight).not.toBeNull();
            expect(defaultHeightNum).toBeLessThan(800);
            expect(defaultHeightNum).toBeGreaterThan(700);
            expect(fix.componentInstance.grid.calcHeight).toBeLessThan(800);
            expect(fix.componentInstance.grid.calcHeight).toBeGreaterThan(700);
            fix.componentInstance.data = fix.componentInstance.fullData;
        }));

        it('should render correct columns if after scrolling right container size changes so that all columns become visible.',
            async () => {
                const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
                fix.detectChanges();
                const grid = fix.componentInstance.grid;
                grid.width = '500px';
                fix.componentInstance.initColumnsRows(5, 5);
                fix.detectChanges();
                await wait(16);
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(true);
                const scrollbar = grid.headerContainer.getScroll();
                scrollbar.scrollLeft = 10000;
                grid.width = '1500px';

                fix.detectChanges();
                await wait(100);
                expect(fix.componentInstance.isHorizonatScrollbarVisible()).toBe(false);
                const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
                expect(headers.length).toEqual(5);
                for (let i = 0; i < headers.length; i++) {
                    expect(headers[i].context.column.field).toEqual(grid.columns[i].field);
                }
            });

        it('Should render date and number values based on default formatting', fakeAsync(() => {
            const fixture = TestBed.createComponent(IgxGridFormattingComponent);
            fixture.detectChanges();
            tick(16);
            const grid = fixture.componentInstance.grid;
            const rows = grid.rowList.toArray();
            // verify default number formatting
            let expectedValue = '2,760';
            expect(rows[0].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '1,098';
            expect(rows[5].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '7,898';
            expect(rows[7].cells.toArray()[3].element.nativeElement.textContent).toBe(expectedValue);
            // verify formatter function formatting
            expectedValue = '2.76e+3';
            expect(rows[0].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '1.098e+3';
            expect(rows[5].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = '7.898e+3';
            expect(rows[7].cells.toArray()[5].element.nativeElement.textContent).toBe(expectedValue);
            // verify date formatting
            expectedValue = 'Mar 21, 2005';
            expect(rows[0].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = 'Jan 15, 2008';
            expect(rows[1].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            expectedValue = 'Nov 20, 2010';
            expect(rows[2].cells.toArray()[4].element.nativeElement.textContent).toBe(expectedValue);
            // verify summaries formatting
            let avgValue;
            let earliestValue;
            const summaries = fixture.debugElement.queryAll(By.css('.igx-grid-summary'));
            summaries.forEach((summary) => {
                const avgLabel = summary.query(By.css('[title=\'Avg\']'));
                const earliest = summary.query(By.css('[title=\'Earliest\']'));
                if (avgLabel) {
                    avgValue = avgLabel.nativeElement.nextSibling.innerText;
                    expect(avgValue).toBe('3,900.4');
                }
                if (earliest) {
                    earliestValue = earliest.nativeElement.nextSibling.innerText;
                    expect(earliestValue).toBe('May 17, 1990');
                }
            });
        }));

        it('Should calculate default column width when a column has width in %', async () => {
            const fix = TestBed.createComponent(IgxGridColumnPercentageWidthComponent);
            fix.componentInstance.initColumnsRows(5, 3);
            await wait(16);
            fix.detectChanges();

            const grid = fix.componentInstance.grid;
            expect(grid.columns[1].width).toEqual('150px');
            expect(grid.columns[2].width).toEqual('150px');

            const hScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            expect(hScroll.nativeElement.hidden).toBe(true);

            grid.columns[0].width = '70%';
            fix.detectChanges();
            await wait(16);
            // check UI
            const header0 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[0];
            const header1 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[1];
            const header2 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[2];

            expect(header0.nativeElement.offsetWidth).toEqual(350);
            expect(header1.nativeElement.offsetWidth).toEqual(136);
            expect(header2.nativeElement.offsetWidth).toEqual(136);
            expect(hScroll.nativeElement.hidden).toBe(false);

            // check virtualization cache is valid
            const virtDir = grid.getRowByIndex(0).virtDirRow;
            expect(virtDir.getSizeAt(0)).toEqual(350);
            expect(virtDir.getSizeAt(1)).toEqual(136);
            expect(virtDir.getSizeAt(2)).toEqual(136);
        });
        it('Should re-calculate column width when a column has width in % and grid width changes.', async () => {
            const fix = TestBed.createComponent(IgxGridColumnPercentageWidthComponent);
            fix.componentInstance.initColumnsRows(5, 3);
            fix.detectChanges();
            await wait(16);

            const grid = fix.componentInstance.grid;
            const hScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            expect(hScroll.nativeElement.hidden).toBe(true);
            grid.columns[0].width = '70%';
            fix.detectChanges();
            await wait(16);
            grid.width = '1000px';
            fix.detectChanges();
            await wait(16);

            // check UI
            const header0 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[0];
            const header1 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[1];
            const header2 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[2];
            expect(header0.nativeElement.offsetWidth).toEqual(700);
            expect(header1.nativeElement.offsetWidth).toEqual(150);
            expect(header2.nativeElement.offsetWidth).toEqual(150);

            expect(hScroll.nativeElement.hidden).toBe(true);
            // check virtualization cache is valid
            const virtDir = grid.getRowByIndex(0).virtDirRow;
            expect(virtDir.getSizeAt(0)).toEqual(700);
            expect(virtDir.getSizeAt(1)).toEqual(150);
            expect(virtDir.getSizeAt(2)).toEqual(150);
        });
        it('Should calculate column width when a column has width in % and row selectors are enabled.', async () => {
            const fix = TestBed.createComponent(IgxGridColumnPercentageWidthComponent);
            fix.componentInstance.initColumnsRows(5, 3);
            await wait(16);
            fix.detectChanges();
            const grid = fix.componentInstance.grid;
            const hScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            grid.rowSelection = GridSelectionMode.multiple;
            fix.detectChanges();
            grid.columns[0].width = '70%';

            fix.detectChanges();
            await wait(16);
            // check UI
            const rowSelectorHeader = fix.nativeElement.querySelector('.igx-grid__thead').querySelector('.igx-grid__cbx-selection');
            const header0 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[0];
            const header1 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[1];
            const header2 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[2];
            const expectedWidth = Math.round(0.7 * (grid.unpinnedWidth + rowSelectorHeader.offsetWidth));
            expect(header0.nativeElement.offsetWidth).toBeGreaterThanOrEqual(expectedWidth - 1);
            expect(header0.nativeElement.offsetWidth).toBeLessThanOrEqual(expectedWidth + 1);
            expect(header1.nativeElement.offsetWidth).toEqual(136);
            expect(header2.nativeElement.offsetWidth).toEqual(136);
            expect(hScroll.nativeElement.hidden).toBe(false);

            // check virtualization cache is valid
            const virtDir = grid.getRowByIndex(0).virtDirRow;
            expect(virtDir.getSizeAt(0)).toEqual(Math.floor(0.7 * grid.unpinnedWidth));
            expect(virtDir.getSizeAt(1)).toEqual(136);
            expect(virtDir.getSizeAt(2)).toEqual(136);

        });
        it('Should render correct column widths when having mixed width setting - px, %, null', async () => {
            const fix = TestBed.createComponent(IgxGridColumnPercentageWidthComponent);
            fix.componentInstance.initColumnsRows(5, 3);
            const grid = fix.componentInstance.grid;
            const hScroll = fix.debugElement.query(By.css('.igx-grid__scroll'));
            fix.detectChanges();
            grid.columns[0].width = '50%';
            grid.columns[1].width = '100px';
            fix.detectChanges();
            await wait(16);
            const header0 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[0];
            const header1 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[1];
            const header2 = fix.debugElement.queryAll(By.css('igx-grid-header-group'))[2];

            expect(header0.nativeElement.offsetWidth).toEqual(250);
            expect(header1.nativeElement.offsetWidth).toEqual(100);
            expect(header2.nativeElement.offsetWidth).toEqual(150);
            expect(hScroll.nativeElement.hidden).toBe(true);

            // check virtualization cache is valid
            const virtDir = grid.getRowByIndex(0).virtDirRow;
            expect(virtDir.getSizeAt(0)).toEqual(250);
            expect(virtDir.getSizeAt(1)).toEqual(100);
            expect(virtDir.getSizeAt(2)).toEqual(150);

        });

        it('should render all columns if grid width is set to null.', async () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(5, 30);
            const grid = fix.componentInstance.grid;
            fix.detectChanges();

            grid.width = null;
            fix.detectChanges();
            await wait(16);

            // grid should render all columns and all should be visible.
            const cells = grid.getRowByIndex(0).cells;
            expect(cells.length).toBe(30);
            expect(parseInt(grid.hostWidth, 10)).toBe(30 * 136);
        });
    });

    describe('IgxGrid - API methods', () => {
        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridDefaultRenderingComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule]
            }).compileComponents();
        }));

        it(`When edit a cell onto filtered data through grid method, the row should
            disapear and the new value should not persist onto the next row`, fakeAsync(() => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(5, 5);
            fix.detectChanges();
            tick(16);

            const grid = fix.componentInstance.grid;
            const cols = fix.componentInstance.columns;
            const editValue = 0;

            grid.filter(cols[1].key, 2, IgxNumberFilteringOperand.instance().condition('greaterThan'));
            fix.detectChanges();
            grid.getCellByColumn(0, cols[1].key).update(editValue);
            fix.detectChanges();
            const gridRows = fix.debugElement.queryAll(By.css('igx-grid-row'));
            expect(gridRows.length).toEqual(1);
            const firstRowCells = gridRows[0].queryAll(By.css('igx-grid-cell'));
            const firstCellInputValue = firstRowCells[1].nativeElement.textContent.trim();
            expect(firstCellInputValue).toEqual('4');
        }));

        it(`GetNextCell: should return correctly next cell coordinates`, async () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(15, 5);
            fix.detectChanges();
            await wait(16);

            const grid = fix.componentInstance.grid;
            grid.height = '500px';
            await wait(30);
            fix.detectChanges();

            grid.getColumnByName('col2').editable = true;
            fix.detectChanges();
            grid.getColumnByName('col4').editable = true;
            fix.detectChanges();
            // when the next cell is on the same row
            let nextCellCoords = grid.getNextCell(0, 0, (col) => col.editable);
            expect(nextCellCoords).toEqual({ rowIndex: 0, visibleColumnIndex: 2 });
            // when the next cell is on the next row
            nextCellCoords = grid.getNextCell(0, 4, (col) => col.editable);
            expect(nextCellCoords).toEqual({ rowIndex: 1, visibleColumnIndex: 2 });
            // when the next cell is not in the view
            nextCellCoords = grid.getNextCell(9, 4, (col) => col.editable);
            expect(nextCellCoords).toEqual({ rowIndex: 10, visibleColumnIndex: 2 });
            // when the current row and column index are not valid
            nextCellCoords = grid.getNextCell(-10, 14, (col) => col.editable);
            expect(nextCellCoords).toEqual({ rowIndex: -10, visibleColumnIndex: 14 });
            // when grid has no data
            grid.filter('col0', 2, IgxNumberFilteringOperand.instance().condition('greaterThan'));
            fix.detectChanges();

            nextCellCoords = grid.getNextCell(0, 0, (col) => col.editable);
            expect(nextCellCoords).toEqual({ rowIndex: 0, visibleColumnIndex: 0 });
        });

        it(`GetPreviousCell: should return correctly next cell coordinates`, async () => {
            const fix = TestBed.createComponent(IgxGridDefaultRenderingComponent);
            fix.componentInstance.initColumnsRows(15, 5);
            fix.detectChanges();
            await wait(16);

            const grid = fix.componentInstance.grid;
            grid.height = '500px';
            await wait(30);
            fix.detectChanges();

            grid.getColumnByName('col2').editable = true;
            fix.detectChanges();
            grid.getColumnByName('col4').editable = true;
            fix.detectChanges();
            // when the previous cell is on the same row
            let prevCellCoords = grid.getPreviousCell(0, 4, (col) => col.editable);
            expect(prevCellCoords).toEqual({ rowIndex: 0, visibleColumnIndex: 2 });
            // when the previous cell is on the previous row
            prevCellCoords = grid.getPreviousCell(1, 2, (col) => col.editable);
            expect(prevCellCoords).toEqual({ rowIndex: 0, visibleColumnIndex: 4 });
            // when the current row and column index are not valid
            prevCellCoords = grid.getPreviousCell(-110, 2, (col) => col.editable);
            expect(prevCellCoords).toEqual({ rowIndex: -110, visibleColumnIndex: 2 });
            // when there is no previous cell
            prevCellCoords = grid.getPreviousCell(0, 2, (col) => col.editable);
            expect(prevCellCoords).toEqual({ rowIndex: 0, visibleColumnIndex: 2 });
            // when the filter function has no matching colums
            prevCellCoords = grid.getPreviousCell(0, 3, (col) => col.movable);
            expect(prevCellCoords).toEqual({ rowIndex: 0, visibleColumnIndex: 3 });
            // when grid has no data
            grid.filter('col0', 2, IgxNumberFilteringOperand.instance().condition('greaterThan'));
            fix.detectChanges();

            prevCellCoords = grid.getPreviousCell(99, 0, (col) => col.editable);
            expect(prevCellCoords).toEqual({ rowIndex: 99, visibleColumnIndex: 0 });
        });
    });

    describe('IgxGrid - Integration with other Igx Controls', () => {
        configureTestSuite();

        let fix;

        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridInsideIgxTabsComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule, IgxTabsModule]
            }).compileComponents();
        }));

        beforeEach(() => {
            fix = TestBed.createComponent(IgxGridInsideIgxTabsComponent);
            fix.detectChanges();
        });

        it('IgxTabs: should initialize a grid with correct width/height', async () => {
            const grid = fix.componentInstance.grid3;
            const tab = fix.componentInstance.tabs;
            expect(grid.calcHeight).toBe(510);
            tab.tabs.toArray()[2].select();
            await wait(100);
            fix.detectChanges();
            await wait(100);
            grid.cdr.detectChanges();
            const gridHeader = fix.debugElement.query(By.css(THEAD_CLASS));
            const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            expect(parseInt(window.getComputedStyle(gridHeader.nativeElement).width, 10)).toBe(600);
            expect(headers.length).toBe(4);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).width, 10)).toBe(600);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(510);
        });

        it('IgxTabs: should initialize a grid with correct width/height when there is no column width set', async () => {

            const grid = fix.componentInstance.grid2;
            const tab = fix.componentInstance.tabs;

            expect(grid.calcHeight).toBe(300);
            tab.tabs.toArray()[1].select();
            await wait(100);
            fix.detectChanges();
            await wait(100);
            grid.cdr.detectChanges();
            const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
            expect(headers.length).toBe(4);
            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).width, 10) + grid.scrollWidth).toBe(500);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(230);
        });

        it('IgxTabs: should initialize a grid with correct height when paging and summaries are enabled', async () => {

            const grid = fix.componentInstance.grid4;
            const tab = fix.componentInstance.tabs;
            tab.tabs.toArray()[3].select();
            await wait(100);
            fix.detectChanges();
            await wait(100);
            grid.cdr.detectChanges();
            const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            const paging = fix.debugElement.query(By.css('.igx-paginator__pager'));
            const summaries = fix.debugElement.queryAll(By.css('igx-grid-summary-cell'));
            expect(headers.length).toBe(4);
            expect(summaries.length).toBe(4);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(139);
            expect(parseInt(window.getComputedStyle(paging.nativeElement).height, 10)).toBe(36);
        });

        it('IgxTabs: should initialize a grid with correct height when height = 100%', async () => {

            const grid = fix.componentInstance.grid5;
            const tab = fix.componentInstance.tabs;
            expect(grid.calcHeight).toBe(204);
            tab.tabs.toArray()[4].select();
            await wait(100);
            fix.detectChanges();
            await wait(100);
            grid.cdr.detectChanges();
            const headers = fix.debugElement.queryAll(By.css(COLUMN_HEADER_CLASS));
            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            const paging = fix.debugElement.query(By.css('.igx-paginator__pager'));
            expect(headers.length).toBe(4);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(204);
            expect(parseInt(window.getComputedStyle(paging.nativeElement).height, 10)).toBe(36);
        });

        it('IgxTabs: should initialize a grid with correct height height = 100% when parent has height', async () => {

            const grid = fix.componentInstance.grid6;
            const tab = fix.componentInstance.tabs;
            expect(grid.calcHeight).toBe(510);
            tab.tabs.toArray()[5].select();
            await wait(100);
            fix.detectChanges();
            await wait(100);
            grid.cdr.detectChanges();
            const gridBody = fix.debugElement.query(By.css(TBODY_CLASS));
            expect(grid.calcHeight).toBe(230);
            expect(parseInt(window.getComputedStyle(gridBody.nativeElement).height, 10)).toBe(230);
            expect(parseInt(window.getComputedStyle(grid.nativeElement).height, 10)).toBe(300);
        });
    });

    describe('IgxGrid - footer section', () => {
        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridWithCustomFooterComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule]
            }).compileComponents();
        }));

        it('should be able to display custom content', () => {
            const fix = TestBed.createComponent(IgxGridWithCustomFooterComponent);
            fix.detectChanges();

            const footer = fix.debugElement.query(By.css('igx-grid-footer')).nativeElement;
            const footerContent = footer.textContent.trim();

            expect(footerContent).toEqual('Custom content');
        });
    });

    describe('IgxGrid - with custom pagination template', () => {
        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridWithCustomPaginationTemplateComponent
                ],
                imports: [
                    NoopAnimationsModule, IgxGridModule]
            }).compileComponents();
        }));

        it('should have access to grid context', () => {
            const fix = TestBed.createComponent(IgxGridWithCustomPaginationTemplateComponent);
            fix.detectChanges();

            const totalRecords = fix.componentInstance.grid.totalRecords.toString();
            const paginationContent = fix.debugElement.query(By.css('.igx-grid__footer > h2')).nativeElement;
            const paginationText = paginationContent.textContent.trim();

            expect(paginationText).toEqual(totalRecords);
        });
    });

    describe('IgxGrid - Performance tests #perf', () => {
        const MAX_RAW_RENDER = 1967; // two average diffs from 7.3 rendering performance
        const MAX_GROUPED_RENDER = 1500;
        const MAX_VER_SCROLL_O = 220;
        const MAX_HOR_SCROLL_O = 220;
        const MAX_VER_SCROLL_U = 380;
        const MAX_HOR_SCROLL_U = 380;
        const MAX_FOCUS = 120;
        let observer: MutationObserver;

        configureTestSuite();
        beforeAll(async(() => {
            TestBed.configureTestingModule({
                declarations: [
                    IgxGridPerformanceComponent
                ],
                imports: [
                    NoopAnimationsModule,
                    IgxGridModule,
                    IgxTabsModule
                ]
            }).compileComponents();
        }));
        afterEach(() => {
            if (observer) {
                observer.disconnect();
            }
        });

        it('should render the grid in a certain amount of time', async () => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.detectChanges();
            expect(fix.componentInstance.delta)
                .withContext('Rendering took: ' + fix.componentInstance.delta +
                    'ms but should have taken at most: ' + MAX_RAW_RENDER + 'ms')
                .toBeLessThan(MAX_RAW_RENDER);
        });

        it('should render grouped grid in a certain amount of time', async () => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.componentInstance.groupingExpressions.push({
                fieldName: 'field0',
                dir: SortingDirection.Asc
            });
            fix.detectChanges();
            expect(fix.componentInstance.delta)
                .withContext('Rendering took: ' + fix.componentInstance.delta +
                    'ms but should have taken at most: ' + MAX_GROUPED_RENDER + 'ms')
                .toBeLessThan(MAX_GROUPED_RENDER);
        });

        xit('should scroll (optimized delta) the grid vertically in a certain amount of time', async (done) => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.detectChanges();
            await wait(16);
            const startTime = new Date().getTime();
            const config: MutationObserverInit = {
                attributes: true,
                attributeOldValue: true,
                attributeFilter: ['ng-reflect-value']
            };
            const callback = () => {
                let ready = true;
                const rows = fix.componentInstance.grid.rowList.toArray();
                for (let i = 0; i < 4; i++) {
                    if (rows[i].cells.first.nativeElement.attributes['ng-reflect-value'].nodeValue !== String(i + 3)) {
                        ready = false;
                        break;
                    }
                }
                if (ready) {
                    const delta = new Date().getTime() - startTime;
                    expect(delta)
                        .withContext('Scrolling took: ' + delta + 'ms but should have taken at most: ' + MAX_VER_SCROLL_O + 'ms')
                        .toBeLessThan(MAX_VER_SCROLL_O);
                    observer.disconnect();
                    done();
                }

            };
            observer = new MutationObserver(callback);
            observer.observe(fix.componentInstance.grid.rowList.first.cells.first.nativeElement, config);
            fix.componentInstance.verticalScroll.scrollTop = 120;
            await wait(100);
            fix.detectChanges();
        });

        xit('should scroll (unoptimized delta) the grid vertically in a certain amount of time', async (done) => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.detectChanges();
            await wait(16);
            const startTime = new Date().getTime();
            const config: MutationObserverInit = {
                attributes: true,
                attributeOldValue: true,
                attributeFilter: ['ng-reflect-value']
            };
            const callback = (mutationsList) => {
                const cellMutated = mutationsList.filter((mutation) => {
                    return mutation.oldValue === '60' && mutation.target.attributes['ng-reflect-value'].nodeValue === '84';
                }).length === 1;
                if (cellMutated) {
                    const delta = new Date().getTime() - startTime;
                    expect(delta)
                        .withContext('Scrolling took: ' + delta + 'ms but should have taken at most: ' + MAX_VER_SCROLL_U + 'ms')
                        .toBeLessThan(MAX_VER_SCROLL_U);
                    observer.disconnect();
                    done();
                }
            };
            observer = new MutationObserver(callback);
            observer.observe(fix.componentInstance.grid.rowList.last.cells.first.nativeElement, config);
            fix.componentInstance.verticalScroll.scrollTop = 800;
            await wait(100);
            fix.detectChanges();
        });

        xit('should scroll (optimized delta) the grid horizontally in a certain amount of time', async (done) => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.detectChanges();
            await wait(16);
            const startTime = new Date().getTime();
            const config: MutationObserverInit = {
                attributes: true,
                attributeOldValue: true,
                attributeFilter: ['ng-reflect-value']
            };
            const callback = (mutationsList) => {
                const cellMutated = mutationsList.filter((mutation) => {
                    return mutation.oldValue === '1' && mutation.target.attributes['ng-reflect-value'].nodeValue === '22';
                }).length === 1;
                if (cellMutated) {
                    const delta = new Date().getTime() - startTime;
                    expect(delta)
                        .withContext('Scrolling took: ' + delta + 'ms but should have taken at most: ' + MAX_HOR_SCROLL_O + 'ms')
                        .toBeLessThan(MAX_HOR_SCROLL_O);
                    observer.disconnect();
                    done();
                }
            };
            observer = new MutationObserver(callback);
            observer.observe(fix.componentInstance.grid.rowList.last.cells.toArray()[1].nativeElement, config);
            fix.componentInstance.horizontalScroll.scrollLeft = 250;
            await wait(100);
            fix.detectChanges();
        });

        xit('should scroll (unoptimized delta) the grid horizontally in a certain amount of time', async (done) => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.detectChanges();
            await wait(16);
            const startTime = new Date().getTime();
            const config: MutationObserverInit = {
                attributes: true,
                attributeOldValue: true,
                attributeFilter: ['ng-reflect-value']
            };
            const callback = (mutationsList) => {
                const cellMutated = mutationsList.filter((mutation) => {
                    return mutation.oldValue === '60' && mutation.target.attributes['ng-reflect-value'].nodeValue === '8';
                }).length === 1;
                if (cellMutated) {
                    const delta = new Date().getTime() - startTime;
                    expect(delta)
                        .withContext('Scrolling took: ' + delta + 'ms but should have taken at most: ' + MAX_HOR_SCROLL_U + 'ms')
                        .toBeLessThan(MAX_HOR_SCROLL_U);
                    observer.disconnect();
                    done();
                }
            };
            observer = new MutationObserver(callback);
            observer.observe(fix.componentInstance.grid.rowList.last.cells.first.nativeElement, config);
            fix.componentInstance.horizontalScroll.scrollLeft = 800;
            await wait(100);
            fix.detectChanges();
        });

        xit('should focus a cell in a certain amount of time', async (done) => {
            const fix = TestBed.createComponent(IgxGridPerformanceComponent);
            fix.detectChanges();
            await wait(16);
            const startTime = new Date().getTime();
            const config: MutationObserverInit = {
                attributes: true,
                attributeOldValue: true,
                attributeFilter: ['aria-selected']
            };
            const callback = (mutationsList) => {
                const cellMutated = mutationsList.filter((mutation) => {
                    return mutation.oldValue === 'false' && mutation.target.attributes['aria-selected'].nodeValue === 'true';
                }).length === 1;
                if (cellMutated) {
                    const delta = new Date().getTime() - startTime;
                    expect(delta)
                        .withContext('Focusing took: ' + delta + 'ms but should have taken at most: ' + MAX_FOCUS + 'ms')
                        .toBeLessThan(MAX_FOCUS);
                    observer.disconnect();
                    done();
                }
            };
            observer = new MutationObserver(callback);
            observer.observe(fix.componentInstance.grid.rowList.first.cells.first.nativeElement, config);
            // UIInteractions.clickElement(fix.componentInstance.grid.rowList.first.cells.first.nativeElement);
            await wait(16);
            fix.detectChanges();
        });
    });
});

@Component({
    template: `<div style="width: 800px; height: 600px;">
        <igx-grid #grid [data]="data" [autoGenerate]="autoGenerate" (onColumnInit)="columnCreated($event)">
            <igx-column *ngFor="let column of columns;" [field]="column.field" [hasSummary]="column.hasSummary"
                [header]="column.field" [width]="column.width">
            </igx-column>
        </igx-grid>
    </div>`
})
export class IgxGridTestComponent {
    public data: any[] = [{ index: 1, value: 1 }];
    public columns = [
        { field: 'index', header: 'index', dataType: 'number', width: null, hasSummary: false },
        { field: 'value', header: 'value', dataType: 'number', width: null, hasSummary: false }
    ];
    @ViewChild('grid', { static: true }) public grid: IgxGridComponent;

    public autoGenerate = false;

    public columnEventCount = 0;

    public columnCreated(column: IgxColumnComponent) {
        this.columnEventCount++;
        column.filterable = true;
        column.sortable = true;
    }

    public isHorizontalScrollbarVisible() {
        const scrollbar = this.grid.headerContainer.getScroll();
        if (scrollbar) {
            return scrollbar.offsetWidth < scrollbar.children[0].offsetWidth;
        }

        return false;
    }

    public getVerticalScrollHeight() {
        const scrollbar = this.grid.verticalScrollContainer.getScroll();
        if (scrollbar) {
            return parseInt(scrollbar.style.height, 10);
        }

        return 0;
    }

    public isVerticalScrollbarVisible() {
        const scrollbar = this.grid.verticalScrollContainer.getScroll();
        if (scrollbar && scrollbar.offsetHeight > 0) {
            return scrollbar.offsetHeight < scrollbar.children[0].offsetHeight;
        }
        return false;
    }

    public generateData(rows) {
        const d = [];
        for (let r = 0; r < rows; r++) {
            const record = {};
            for (let c = 0; c < this.columns.length; c++) {
                record[this.columns[c].field] = c * r;
            }
            d.push(record);
        }
        this.data = d;
    }

    public clearData() {
        this.data = [];
    }
}

@Component({
    template: `<igx-grid #grid [data]="data" (onColumnInit)="initColumns($event)">
        <igx-column *ngFor="let col of columns" [field]="col.key" [header]="col.key" [dataType]="col.dataType">
        </igx-column>
    </igx-grid>`
})
export class IgxGridDefaultRenderingComponent {
    public columns = [];
    public data = [];

    public changeInitColumns = false;

    @ViewChild('grid', { read: IgxGridComponent, static: true })
    public grid: IgxGridComponent;

    public initColumnsRows(rowsNumber: number, columnsNumber: number): void {
        this.columns = [];
        this.data = [];
        let i, j: number;
        for (i = 0; i < columnsNumber; i++) {
            this.columns.push({
                key: 'col' + i,
                dataType: 'number'
            });
        }
        for (i = 0; i < rowsNumber; i++) {
            const record = {};
            for (j = 0; j < columnsNumber; j++) {
                record[this.columns[j].key] = j * i;
            }
            this.data.push(record);
        }
    }

    public isHorizonatScrollbarVisible() {
        const scrollbar = this.grid.headerContainer.getScroll();
        return scrollbar.offsetWidth < scrollbar.children[0].offsetWidth;
    }

    public initColumns(column) {
        if (this.changeInitColumns) {
            switch (this.grid.columnList.length) {
                case 5:
                    if (column.index === 0 || column.index === 4) {
                        column.width = '100px';
                    }
                    break;
                case 30:
                    if (column.index === 0 || column.index === 5 || column.index === 3 || column.index === 10 || column.index === 25) {
                        column.width = '200px';
                    }
                    break;
                case 150:
                    if (column.index === 0 || column.index === 5 || column.index === 3 || column.index === 10 || column.index === 50) {
                        column.width = '500px';
                    }
                    break;
            }
        }
    }
}

@Component({
    template: `<igx-grid #grid [data]="data" [width]="'500px'" (onColumnInit)="initColumns($event)">
        <igx-column *ngFor="let col of columns" [field]="col.key" [header]="col.key" [dataType]="col.dataType">
        </igx-column>
    </igx-grid>`
})
export class IgxGridColumnPercentageWidthComponent extends IgxGridDefaultRenderingComponent {
    public initColumns(column) {
        if (column.index === 0) {
            column.width = '40%';
        }
    }
}

@Component({
    template:
        `<div>
        <igx-grid #grid [data]="data" [displayDensity]="'compact'" [autoGenerate]="true"
            [paging]="true" [perPage]="5">
            <igx-grid-footer>
            Custom content
            </igx-grid-footer>
        </igx-grid>
        </div>`
})
export class IgxGridWithCustomFooterComponent extends IgxGridTestComponent {
}
@Component({
    template:
        `<div [style.width.px]="outerWidth" [style.height.px]="outerHeight">
            <igx-grid #grid [data]="data" [displayDensity]="density" [autoGenerate]="true"
                [paging]="paging" [perPage]="pageSize">
            </igx-grid>
        </div>`
})
export class IgxGridWrappedInContComponent extends IgxGridTestComponent {
    public data = [];

    public fullData = [
        { 'ID': 'ALFKI', 'CompanyName': 'Alfreds Futterkiste' },
        { 'ID': 'ANATR', 'CompanyName': 'Ana Trujillo Emparedados y helados' },
        { 'ID': 'ANTON', 'CompanyName': 'Antonio Moreno Taquería' },
        { 'ID': 'AROUT', 'CompanyName': 'Around the Horn' },
        { 'ID': 'BERGS', 'CompanyName': 'Berglunds snabbköp' },
        { 'ID': 'BLAUS', 'CompanyName': 'Blauer See Delikatessen' },
        { 'ID': 'BLONP', 'CompanyName': 'Blondesddsl père et fils' },
        { 'ID': 'BOLID', 'CompanyName': 'Bólido Comidas preparadas' },
        { 'ID': 'BONAP', 'CompanyName': 'Bon app\'' },
        { 'ID': 'BOTTM', 'CompanyName': 'Bottom-Dollar Markets' },
        { 'ID': 'BSBEV', 'CompanyName': 'B\'s Beverages' },
        { 'ID': 'CACTU', 'CompanyName': 'Cactus Comidas para llevar' },
        { 'ID': 'CENTC', 'CompanyName': 'Centro comercial Moctezuma' },
        { 'ID': 'CHOPS', 'CompanyName': 'Chop-suey Chinese' },
        { 'ID': 'COMMI', 'CompanyName': 'Comércio Mineiro' },
        { 'ID': 'CONSH', 'CompanyName': 'Consolidated Holdings' },
        { 'ID': 'DRACD', 'CompanyName': 'Drachenblut Delikatessen' },
        { 'ID': 'DUMON', 'CompanyName': 'Du monde entier' },
        { 'ID': 'EASTC', 'CompanyName': 'Eastern Connection' },
        { 'ID': 'ERNSH', 'CompanyName': 'Ernst Handel' },
        { 'ID': 'FAMIA', 'CompanyName': 'Familia Arquibaldo' },
        { 'ID': 'FISSA', 'CompanyName': 'FISSA Fabrica Inter' },
        { 'ID': 'FOLIG', 'CompanyName': 'Folies gourmandes' },
        { 'ID': 'FOLKO', 'CompanyName': 'Folk och fä HB' },
        { 'ID': 'FRANK', 'CompanyName': 'Frankenversand' },
        { 'ID': 'FRANR', 'CompanyName': 'France restauration' },
        { 'ID': 'FRANS', 'CompanyName': 'Franchi S.p.A.' }
    ];

    public get semiData(): any[] {
        return this.fullData.slice(0, 5);
    }

    public height = null;
    public paging = false;
    public pageSize = 5;
    public density = DisplayDensity.comfortable;
    public outerWidth = 800;
    public outerHeight: number;
}

@Component({
    template:
        `<div style="height:300px">
            <igx-grid #grid [data]="data" [displayDensity]="density" [autoGenerate]="true"
                [paging]="paging" [perPage]="pageSize">
            </igx-grid>
        </div>`
})
export class IgxGridFixedContainerHeightComponent extends IgxGridWrappedInContComponent {
    public paging = false;
    public pageSize = 5;
    public density = DisplayDensity.comfortable;
}

@Component({
    template: `
        <igx-grid [data]="data" (onColumnInit)="columnCreated($event)">
            <igx-column field="ID"></igx-column>
            <igx-column field="Name"></igx-column>
        </igx-grid>
    `
})
export class IgxGridMarkupDeclarationComponent extends IgxGridTestComponent {
    public data = [
        { ID: 1, Name: 'Johny' },
        { ID: 2, Name: 'Sally' },
        { ID: 3, Name: 'Tim' }
    ];
    @ViewChild(IgxGridComponent, { read: IgxGridComponent, static: true })
    public instance: IgxGridComponent;
}

@Component({
    template: `<div>
        <igx-grid [data]="data" (onColumnInit)="columnCreated($event)">
            <igx-column field="ID"></igx-column>
            <igx-column field="Name"></igx-column>
        </igx-grid>
        </div>
    `
})
export class IgxGridEmptyMessage100PercentComponent extends IgxGridTestComponent {
    public data = [];
    @ViewChild(IgxGridComponent, { read: IgxGridComponent, static: true })
    public grid: IgxGridComponent;
}

@Injectable()
export class LocalService {
    public records: Observable<any[]>;
    private _records: BehaviorSubject<any[]>;
    private dataStore: any[];

    constructor() {
        this.dataStore = [];
        this._records = new BehaviorSubject([]);
        this.records = this._records.asObservable();
    }

    nullData() {
        this._records.next(null);
    }

    public getData(data?: IForOfState, cb?: (any) => void): any {
        const size = data.chunkSize === 0 ? 10 : data.chunkSize;
        this.dataStore = this.generateData(data.startIndex, data.startIndex + size);
        this._records.next(this.dataStore);
        const count = 1000;
        if (cb) {
            cb(count);
        }
    }

    public generateData(start, end) {
        const dummyData = [];
        for (let i = start; i < end; i++) {
            dummyData.push({ Col1: 10 * i });
        }
        return dummyData;
    }
}

@Component({
    template: `
        <igx-grid [data]="data | async" (onDataPreLoad)="dataLoading($event)" [height]="'600px'">
            <igx-column [sortable]="true" [filterable]="true" [field]="'Col1'" [header]="'Col1'">
            </igx-column>
        </igx-grid>
    `,
    providers: [LocalService]
})
export class IgxGridRemoteVirtualizationComponent implements OnInit, AfterViewInit {
    public data;
    @ViewChild(IgxGridComponent, { read: IgxGridComponent, static: true })
    public instance: IgxGridComponent;
    constructor(private localService: LocalService, public cdr: ChangeDetectorRef) { }
    public ngOnInit(): void {
        this.data = this.localService.records;
    }

    nullData() {
        this.localService.nullData();
    }

    public ngAfterViewInit() {
        this.localService.getData(this.instance.virtualizationState, (count) => {
            this.instance.totalItemCount = count;
            this.cdr.detectChanges();
        });
    }

    dataLoading(evt) {
        this.localService.getData(evt, () => {
            this.cdr.detectChanges();
        });
    }
}

@Component({
    template: `
        <igx-grid [data]="data | async" (onDataPreLoad)="dataLoading($event)" [isLoading]="true" [autoGenerate]="true" [height]="'600px'">
        </igx-grid>

        <ng-template #customTemplate>
            <span>Loading...</span>
        </ng-template>
    `,
    providers: [LocalService]
})
export class IgxGridRemoteOnDemandComponent {
    public data;
    @ViewChild(IgxGridComponent, { read: IgxGridComponent, static: true })
    public instance: IgxGridComponent;
    @ViewChild('customTemplate', { read: TemplateRef, static: true })
    public customTemaplate: TemplateRef<any>;
    constructor(private localService: LocalService, public cdr: ChangeDetectorRef) { }

    public bind() {
        this.data = this.localService.records;
        this.localService.getData(this.instance.virtualizationState, (count) => {
            this.instance.totalItemCount = count;
            this.cdr.detectChanges();
        });
    }

    dataLoading(evt) {
        this.localService.getData(evt, () => {
            this.cdr.detectChanges();
        });
    }
}

@Component({
    template: GridTemplateStrings.declareGrid(
        '', '',
        `<igx-column field="ProductID" header="Product ID">
        </igx-column>
        <igx-column field="ProductName">
        </igx-column>
        <igx-column field="InStock" [dataType]="'boolean'">
        </igx-column>
        <igx-column field="UnitsInStock" [dataType]="'number'" [hasSummary]="true">
        </igx-column>
        <igx-column field="OrderDate" width="200px" [dataType]="'date'" [hasSummary]="true">
        </igx-column><igx-column field="UnitsInStock" [formatter]="formatNum" [dataType]="'number'" [hasSummary]="true">
        </igx-column>`)
})
export class IgxGridFormattingComponent extends BasicGridComponent {
    public data = SampleTestData.foodProductData();
    @ViewChild(IgxGridComponent, { static: true }) public grid: IgxGridComponent;
    public width = '600px';
    public height = '400px';
    public value: any;
    public formatNum() {
        return this.value.toExponential().toString();
    }
}

@Component({
    template: `
    <div style="width: 600px; height: 400px;">
    <igx-tabs #tabs>
      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
      <igx-tabs-group label="Tab 2">
        <igx-grid #grid2 [data]="data" [primaryKey]="'id'" [width]="'500px'" [height]="'300px'">
        <igx-column
            *ngFor="let column of columns"
            [field]="column.field"
            [header]="column.field"
        >
        </igx-column>
        </igx-grid>
      </igx-tabs-group>
      <igx-tabs-group label="Tab 3">
        <igx-grid #grid3 [data]="data" [primaryKey]="'id'">
        <igx-column
            *ngFor="let column of columns"
            [field]="column.field"
            [header]="column.field"
            [width]="column.width"
        >
        </igx-column>
        </igx-grid>
      </igx-tabs-group>
      <igx-tabs-group label="Tab 4">
        <igx-grid #grid4 [data]="data" [primaryKey]="'id'" [width]="'500px'" [height]="'300px'"
            [paging]="true" [perPage]="3">
        <igx-column
            *ngFor="let column of columns"
            [field]="column.field"
            [header]="column.field"
            [hasSummary]="true"
        >
        </igx-column>
        </igx-grid>
      </igx-tabs-group>
      <igx-tabs-group label="Tab 5">
        <igx-grid #grid5 [data]="data" [primaryKey]="'id'" [width]="'500px'" [height]="'100%'"
            [paging]="true" [perPage]="4">
        <igx-column
            *ngFor="let column of columns"
            [field]="column.field"
            [header]="column.field"
        >
        </igx-column>
        </igx-grid>
      </igx-tabs-group>
      <igx-tabs-group label="Tab 6">
      <div style='height:300px;'>
      <igx-grid #grid6 [data]="data" [primaryKey]="'id'" [width]="'500px'" [height]="'100%'"
       >
      <igx-column
          *ngFor="let column of columns"
          [field]="column.field"
          [header]="column.field"
      >
      </igx-column>
      </igx-grid>
      </div>
    </igx-tabs-group>
    </igx-tabs>
  </div>
    `
})
export class IgxGridInsideIgxTabsComponent {
    @ViewChild('grid2', { read: IgxGridComponent, static: true })
    public grid2: IgxGridComponent;
    @ViewChild('grid3', { read: IgxGridComponent, static: true })
    public grid3: IgxGridComponent;
    @ViewChild('grid4', { read: IgxGridComponent, static: true })
    public grid4: IgxGridComponent;
    @ViewChild('grid5', { read: IgxGridComponent, static: true })
    public grid5: IgxGridComponent;
    @ViewChild('grid6', { read: IgxGridComponent, static: true })
    public grid6: IgxGridComponent;
    @ViewChild(IgxTabsComponent, { read: IgxTabsComponent, static: true })
    public tabs: IgxTabsComponent;

    public columns = [
        { field: 'id', width: 100 },
        { field: '1', width: 100 },
        { field: '2', width: 100 },
        { field: '3', width: 100 }
    ];

    public data = [];

    constructor() {
        const data = [];
        for (let j = 1; j <= 10; j++) {
            const item = {};
            item['id'] = j;
            for (let k = 2, len = this.columns.length; k <= len; k++) {
                const field = this.columns[k - 1].field;
                item[field] = `item${j}-${k}`;
            }
            data.push(item);
        }
        this.data = data;
    }
}

@Component({
    template: `
        <igx-grid #grid [data]="data"
        [paging]="true" [paginationTemplate]="pager" [autoGenerate]="true">
        </igx-grid>
        <ng-template #pager let-grid>
            <h2>{{grid.totalRecords}}</h2>
        </ng-template>
    `
})
export class IgxGridWithCustomPaginationTemplateComponent {
    public data = SampleTestData.foodProductData();
    @ViewChild('grid', { read: IgxGridComponent, static: true })
    public grid: IgxGridComponent;
}

@Component({
    template: `<igx-grid #grid [width]="'2000px'" [height]="'2000px'" [data]="data"
        [autoGenerate]="autoGenerate" [displayDensity]="'compact'" [groupingExpressions]="groupingExpressions">
        <igx-column *ngFor="let column of columns" [field]="column.field" [header]="column.field" [width]="column.width"></igx-column>
    </igx-grid>`
})
export class IgxGridPerformanceComponent implements AfterViewInit, OnInit {

    @ViewChild('grid', { read: IgxGridComponent, static: true }) public grid: IgxGridComponent;

    public columns = [];
    public data = [];

    public startTime;
    public delta;

    public groupingExpressions: Array<ISortingExpression> = [];

    public get verticalScroll() {
        return this.grid.verticalScrollContainer.getScroll();
    }

    public get horizontalScroll() {
        return this.grid.headerContainer.getScroll();
    }

    public ngOnInit() {
        const cols = [], d = [];
        for (let i = 0; i < 30; i++) {
            cols.push({ field: 'field' + i, width: '100px', hasSummary: false });
        }
        for (let i = 0; i < 10000; i++) {
            const r = {};
            r['field0'] = i;
            for (let j = 1; j < 30; j++) {
                r['field' + j] = j;
            }
            d.push(r);
        }
        this.columns = cols;
        this.data = d;
        this.startTime = new Date().getTime();
    }

    public ngAfterViewInit() {
        this.delta = new Date().getTime() - this.startTime;
    }
}
